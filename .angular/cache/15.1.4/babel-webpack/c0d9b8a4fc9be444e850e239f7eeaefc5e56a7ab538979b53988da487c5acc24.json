{"ast":null,"code":"import * as i3 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Self, Directive, Input, NgModule } from '@angular/core';\nimport { __decorate } from 'tslib';\nimport { Subject, from } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { IconService, IconDirective } from '@ant-design/icons-angular';\nimport { warn } from 'ng-zorro-antd/core/logger';\nimport { InputBoolean } from 'ng-zorro-antd/core/util';\nimport { DOCUMENT } from '@angular/common';\nimport { BarsOutline, CalendarOutline, CaretUpFill, CaretUpOutline, CaretDownFill, CaretDownOutline, CheckCircleFill, CheckCircleOutline, CheckOutline, ClockCircleOutline, CloseCircleOutline, CloseCircleFill, CloseOutline, CopyOutline, DeleteOutline, DoubleLeftOutline, DoubleRightOutline, DownOutline, EditOutline, EllipsisOutline, ExclamationCircleFill, ExclamationCircleOutline, EyeOutline, FileFill, FileOutline, FilterFill, InfoCircleFill, InfoCircleOutline, LeftOutline, LoadingOutline, PaperClipOutline, QuestionCircleOutline, RightOutline, RotateRightOutline, RotateLeftOutline, StarFill, SearchOutline, UploadOutline, VerticalAlignTopOutline, UpOutline, SwapRightOutline, ZoomInOutline, ZoomOutOutline } from '@ant-design/icons-angular/icons';\nimport * as i1 from '@angular/platform-browser';\nimport * as i2 from 'ng-zorro-antd/core/config';\nimport * as i4 from '@angular/common/http';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst NZ_ICONS_USED_BY_ZORRO = [BarsOutline, CalendarOutline, CaretUpFill, CaretUpOutline, CaretDownFill, CaretDownOutline, CheckCircleFill, CheckCircleOutline, CheckOutline, ClockCircleOutline, CloseCircleOutline, CloseCircleFill, CloseOutline, CopyOutline, DeleteOutline, DoubleLeftOutline, DoubleRightOutline, DownOutline, EditOutline, EllipsisOutline, ExclamationCircleFill, ExclamationCircleOutline, EyeOutline, FileFill, FileOutline, FilterFill, InfoCircleFill, InfoCircleOutline, LeftOutline, LoadingOutline, PaperClipOutline, QuestionCircleOutline, RightOutline, RotateRightOutline, RotateLeftOutline, StarFill, SearchOutline, StarFill, UploadOutline, VerticalAlignTopOutline, UpOutline, SwapRightOutline, ZoomInOutline, ZoomOutOutline];\nconst NZ_ICONS = new InjectionToken('nz_icons');\nconst NZ_ICON_DEFAULT_TWOTONE_COLOR = new InjectionToken('nz_icon_default_twotone_color');\nconst DEFAULT_TWOTONE_COLOR = '#1890ff';\n/**\n * It should be a global singleton, otherwise registered icons could not be found.\n */\nlet NzIconService = /*#__PURE__*/(() => {\n  class NzIconService extends IconService {\n    constructor(rendererFactory, sanitizer, nzConfigService, platform, handler, _document, icons) {\n      super(rendererFactory, handler, _document, sanitizer, [...NZ_ICONS_USED_BY_ZORRO, ...(icons || [])]);\n      this.nzConfigService = nzConfigService;\n      this.platform = platform;\n      this.configUpdated$ = new Subject();\n      this.iconfontCache = new Set();\n      this.subscription = null;\n      this.onConfigChange();\n      this.configDefaultTwotoneColor();\n      this.configDefaultTheme();\n    }\n    get _disableDynamicLoading() {\n      return !this.platform.isBrowser;\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n        this.subscription = null;\n      }\n    }\n    normalizeSvgElement(svg) {\n      if (!svg.getAttribute('viewBox')) {\n        this._renderer.setAttribute(svg, 'viewBox', '0 0 1024 1024');\n      }\n      if (!svg.getAttribute('width') || !svg.getAttribute('height')) {\n        this._renderer.setAttribute(svg, 'width', '1em');\n        this._renderer.setAttribute(svg, 'height', '1em');\n      }\n      if (!svg.getAttribute('fill')) {\n        this._renderer.setAttribute(svg, 'fill', 'currentColor');\n      }\n    }\n    fetchFromIconfont(opt) {\n      const {\n        scriptUrl\n      } = opt;\n      if (this._document && !this.iconfontCache.has(scriptUrl)) {\n        const script = this._renderer.createElement('script');\n        this._renderer.setAttribute(script, 'src', scriptUrl);\n        this._renderer.setAttribute(script, 'data-namespace', scriptUrl.replace(/^(https?|http):/g, ''));\n        this._renderer.appendChild(this._document.body, script);\n        this.iconfontCache.add(scriptUrl);\n      }\n    }\n    createIconfontIcon(type) {\n      return this._createSVGElementFromString(`<svg><use xlink:href=\"${type}\"></svg>`);\n    }\n    onConfigChange() {\n      this.subscription = this.nzConfigService.getConfigChangeEventForComponent('icon').subscribe(() => {\n        this.configDefaultTwotoneColor();\n        this.configDefaultTheme();\n        this.configUpdated$.next();\n      });\n    }\n    configDefaultTheme() {\n      const iconConfig = this.getConfig();\n      this.defaultTheme = iconConfig.nzTheme || 'outline';\n    }\n    configDefaultTwotoneColor() {\n      const iconConfig = this.getConfig();\n      const defaultTwotoneColor = iconConfig.nzTwotoneColor || DEFAULT_TWOTONE_COLOR;\n      let primaryColor = DEFAULT_TWOTONE_COLOR;\n      if (defaultTwotoneColor) {\n        if (defaultTwotoneColor.startsWith('#')) {\n          primaryColor = defaultTwotoneColor;\n        } else {\n          warn('Twotone color must be a hex color!');\n        }\n      }\n      this.twoToneColor = {\n        primaryColor\n      };\n    }\n    getConfig() {\n      return this.nzConfigService.getConfigForComponent('icon') || {};\n    }\n  }\n  NzIconService.ɵfac = function NzIconService_Factory(t) {\n    return new (t || NzIconService)(i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(i1.DomSanitizer), i0.ɵɵinject(i2.NzConfigService), i0.ɵɵinject(i3.Platform), i0.ɵɵinject(i4.HttpBackend, 8), i0.ɵɵinject(DOCUMENT, 8), i0.ɵɵinject(NZ_ICONS, 8));\n  };\n  NzIconService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzIconService,\n    factory: NzIconService.ɵfac,\n    providedIn: 'root'\n  });\n  return NzIconService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NZ_ICONS_PATCH = new InjectionToken('nz_icons_patch');\nlet NzIconPatchService = /*#__PURE__*/(() => {\n  class NzIconPatchService {\n    constructor(extraIcons, rootIconService) {\n      this.extraIcons = extraIcons;\n      this.rootIconService = rootIconService;\n      this.patched = false;\n    }\n    doPatch() {\n      if (this.patched) {\n        return;\n      }\n      this.extraIcons.forEach(iconDefinition => this.rootIconService.addIcon(iconDefinition));\n      this.patched = true;\n    }\n  }\n  NzIconPatchService.ɵfac = function NzIconPatchService_Factory(t) {\n    return new (t || NzIconPatchService)(i0.ɵɵinject(NZ_ICONS_PATCH, 2), i0.ɵɵinject(NzIconService));\n  };\n  NzIconPatchService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzIconPatchService,\n    factory: NzIconPatchService.ɵfac\n  });\n  return NzIconPatchService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NzIconDirective = /*#__PURE__*/(() => {\n  class NzIconDirective extends IconDirective {\n    constructor(ngZone, changeDetectorRef, elementRef, iconService, renderer, iconPatch) {\n      super(iconService, elementRef, renderer);\n      this.ngZone = ngZone;\n      this.changeDetectorRef = changeDetectorRef;\n      this.iconService = iconService;\n      this.renderer = renderer;\n      this.cacheClassName = null;\n      this.nzRotate = 0;\n      this.spin = false;\n      this.destroy$ = new Subject();\n      if (iconPatch) {\n        iconPatch.doPatch();\n      }\n      this.el = elementRef.nativeElement;\n    }\n    set nzSpin(value) {\n      this.spin = value;\n    }\n    set nzType(value) {\n      this.type = value;\n    }\n    set nzTheme(value) {\n      this.theme = value;\n    }\n    set nzTwotoneColor(value) {\n      this.twoToneColor = value;\n    }\n    set nzIconfont(value) {\n      this.iconfont = value;\n    }\n    ngOnChanges(changes) {\n      const {\n        nzType,\n        nzTwotoneColor,\n        nzSpin,\n        nzTheme,\n        nzRotate\n      } = changes;\n      if (nzType || nzTwotoneColor || nzSpin || nzTheme) {\n        this.changeIcon2();\n      } else if (nzRotate) {\n        this.handleRotate(this.el.firstChild);\n      } else {\n        this._setSVGElement(this.iconService.createIconfontIcon(`#${this.iconfont}`));\n      }\n    }\n    ngOnInit() {\n      this.renderer.setAttribute(this.el, 'class', `anticon ${this.el.className}`.trim());\n    }\n    /**\n     * If custom content is provided, try to normalize SVG elements.\n     */\n    ngAfterContentChecked() {\n      if (!this.type) {\n        const children = this.el.children;\n        let length = children.length;\n        if (!this.type && children.length) {\n          while (length--) {\n            const child = children[length];\n            if (child.tagName.toLowerCase() === 'svg') {\n              this.iconService.normalizeSvgElement(child);\n            }\n          }\n        }\n      }\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n    }\n    /**\n     * Replacement of `changeIcon` for more modifications.\n     */\n    changeIcon2() {\n      this.setClassName();\n      // The Angular zone is left deliberately before the SVG is set\n      // since `_changeIcon` spawns asynchronous tasks as promise and\n      // HTTP calls. This is used to reduce the number of change detections\n      // while the icon is being loaded dynamically.\n      this.ngZone.runOutsideAngular(() => {\n        from(this._changeIcon()).pipe(takeUntil(this.destroy$)).subscribe({\n          next: svgOrRemove => {\n            // Get back into the Angular zone after completing all the tasks.\n            // Since we manually run change detection locally, we have to re-enter\n            // the zone because the change detection might also be run on other local\n            // components, leading them to handle template functions outside of the Angular zone.\n            this.ngZone.run(() => {\n              // The _changeIcon method would call Renderer to remove the element of the old icon,\n              // which would call `markElementAsRemoved` eventually,\n              // so we should call `detectChanges` to tell Angular remove the DOM node.\n              // #7186\n              this.changeDetectorRef.detectChanges();\n              if (svgOrRemove) {\n                this.setSVGData(svgOrRemove);\n                this.handleSpin(svgOrRemove);\n                this.handleRotate(svgOrRemove);\n              }\n            });\n          },\n          error: warn\n        });\n      });\n    }\n    handleSpin(svg) {\n      if (this.spin || this.type === 'loading') {\n        this.renderer.addClass(svg, 'anticon-spin');\n      } else {\n        this.renderer.removeClass(svg, 'anticon-spin');\n      }\n    }\n    handleRotate(svg) {\n      if (this.nzRotate) {\n        this.renderer.setAttribute(svg, 'style', `transform: rotate(${this.nzRotate}deg)`);\n      } else {\n        this.renderer.removeAttribute(svg, 'style');\n      }\n    }\n    setClassName() {\n      if (this.cacheClassName) {\n        this.renderer.removeClass(this.el, this.cacheClassName);\n      }\n      this.cacheClassName = `anticon-${this.type}`;\n      this.renderer.addClass(this.el, this.cacheClassName);\n    }\n    setSVGData(svg) {\n      this.renderer.setAttribute(svg, 'data-icon', this.type);\n      this.renderer.setAttribute(svg, 'aria-hidden', 'true');\n    }\n  }\n  NzIconDirective.ɵfac = function NzIconDirective_Factory(t) {\n    return new (t || NzIconDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NzIconService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(NzIconPatchService, 8));\n  };\n  NzIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzIconDirective,\n    selectors: [[\"\", \"nz-icon\", \"\"]],\n    hostVars: 2,\n    hostBindings: function NzIconDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"anticon\", true);\n      }\n    },\n    inputs: {\n      nzSpin: \"nzSpin\",\n      nzRotate: \"nzRotate\",\n      nzType: \"nzType\",\n      nzTheme: \"nzTheme\",\n      nzTwotoneColor: \"nzTwotoneColor\",\n      nzIconfont: \"nzIconfont\"\n    },\n    exportAs: [\"nzIcon\"],\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n  });\n  __decorate([InputBoolean()], NzIconDirective.prototype, \"nzSpin\", null);\n  return NzIconDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzIconModule = /*#__PURE__*/(() => {\n  class NzIconModule {\n    static forRoot(icons) {\n      return {\n        ngModule: NzIconModule,\n        providers: [{\n          provide: NZ_ICONS,\n          useValue: icons\n        }]\n      };\n    }\n    static forChild(icons) {\n      return {\n        ngModule: NzIconModule,\n        providers: [NzIconPatchService, {\n          provide: NZ_ICONS_PATCH,\n          useValue: icons\n        }]\n      };\n    }\n  }\n  NzIconModule.ɵfac = function NzIconModule_Factory(t) {\n    return new (t || NzIconModule)();\n  };\n  NzIconModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NzIconModule\n  });\n  NzIconModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [PlatformModule]\n  });\n  return NzIconModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_TWOTONE_COLOR, NZ_ICONS, NZ_ICONS_PATCH, NZ_ICONS_USED_BY_ZORRO, NZ_ICON_DEFAULT_TWOTONE_COLOR, NzIconDirective, NzIconModule, NzIconPatchService, NzIconService };\n//# sourceMappingURL=ng-zorro-antd-icon.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}