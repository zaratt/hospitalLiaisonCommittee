{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { auditTime, finalize, map, filter, takeUntil, startWith, distinctUntilChanged } from 'rxjs/operators';\nimport { environment } from 'ng-zorro-antd/core/environments';\nimport { getEventPosition, isTouchEvent } from 'ng-zorro-antd/core/util';\nimport { DOCUMENT } from '@angular/common';\nimport { reqAnimFrame } from 'ng-zorro-antd/core/polyfill';\nimport * as i2 from '@angular/cdk/layout';\nimport * as i1 from '@angular/cdk/platform';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst NOOP = () => {};\nlet NzResizeService = /*#__PURE__*/(() => {\n  class NzResizeService {\n    constructor(ngZone, rendererFactory2) {\n      this.ngZone = ngZone;\n      this.rendererFactory2 = rendererFactory2;\n      this.resizeSource$ = new Subject();\n      this.listeners = 0;\n      this.disposeHandle = NOOP;\n      this.handler = () => {\n        this.ngZone.run(() => {\n          this.resizeSource$.next();\n        });\n      };\n      this.renderer = this.rendererFactory2.createRenderer(null, null);\n    }\n    ngOnDestroy() {\n      // Caretaker note: the `handler` is an instance property (it's not defined on the class prototype).\n      // The `handler` captures `this` and prevents the `NzResizeService` from being GC'd.\n      this.handler = NOOP;\n    }\n    subscribe() {\n      this.registerListener();\n      return this.resizeSource$.pipe(auditTime(16), finalize(() => this.unregisterListener()));\n    }\n    unsubscribe() {\n      this.unregisterListener();\n    }\n    registerListener() {\n      if (this.listeners === 0) {\n        this.ngZone.runOutsideAngular(() => {\n          this.disposeHandle = this.renderer.listen('window', 'resize', this.handler);\n        });\n      }\n      this.listeners += 1;\n    }\n    unregisterListener() {\n      this.listeners -= 1;\n      if (this.listeners === 0) {\n        this.disposeHandle();\n        this.disposeHandle = NOOP;\n      }\n    }\n  }\n  NzResizeService.ɵfac = function NzResizeService_Factory(t) {\n    return new (t || NzResizeService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.RendererFactory2));\n  };\n  NzResizeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzResizeService,\n    factory: NzResizeService.ɵfac,\n    providedIn: 'root'\n  });\n  return NzResizeService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n/**\n * When running in test, singletons should not be destroyed. So we keep references of singletons\n * in this global variable.\n */\nconst testSingleRegistry = new Map();\n/**\n * Some singletons should have life cycle that is same to Angular's. This service make sure that\n * those singletons get destroyed in HMR.\n */\nlet NzSingletonService = /*#__PURE__*/(() => {\n  class NzSingletonService {\n    constructor() {\n      /**\n       * This registry is used to register singleton in dev mode.\n       * So that singletons get destroyed when hot module reload happens.\n       *\n       * This works in prod mode too but with no specific effect.\n       */\n      this._singletonRegistry = new Map();\n    }\n    get singletonRegistry() {\n      return environment.isTestMode ? testSingleRegistry : this._singletonRegistry;\n    }\n    registerSingletonWithKey(key, target) {\n      const alreadyHave = this.singletonRegistry.has(key);\n      const item = alreadyHave ? this.singletonRegistry.get(key) : this.withNewTarget(target);\n      if (!alreadyHave) {\n        this.singletonRegistry.set(key, item);\n      }\n    }\n    getSingletonWithKey(key) {\n      return this.singletonRegistry.has(key) ? this.singletonRegistry.get(key).target : null;\n    }\n    withNewTarget(target) {\n      return {\n        target\n      };\n    }\n  }\n  NzSingletonService.ɵfac = function NzSingletonService_Factory(t) {\n    return new (t || NzSingletonService)();\n  };\n  NzSingletonService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzSingletonService,\n    factory: NzSingletonService.ɵfac,\n    providedIn: 'root'\n  });\n  return NzSingletonService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nfunction getPagePosition(event) {\n  const e = getEventPosition(event);\n  return {\n    x: e.pageX,\n    y: e.pageY\n  };\n}\n/**\n * This module provide a global dragging service to other components.\n */\nlet NzDragService = /*#__PURE__*/(() => {\n  class NzDragService {\n    constructor(rendererFactory2) {\n      this.draggingThreshold = 5;\n      this.currentDraggingSequence = null;\n      this.currentStartingPoint = null;\n      this.handleRegistry = new Set();\n      this.renderer = rendererFactory2.createRenderer(null, null);\n    }\n    requestDraggingSequence(event) {\n      if (!this.handleRegistry.size) {\n        this.registerDraggingHandler(isTouchEvent(event));\n      }\n      // Complete last dragging sequence if a new target is dragged.\n      if (this.currentDraggingSequence) {\n        this.currentDraggingSequence.complete();\n      }\n      this.currentStartingPoint = getPagePosition(event);\n      this.currentDraggingSequence = new Subject();\n      return this.currentDraggingSequence.pipe(map(e => ({\n        x: e.pageX - this.currentStartingPoint.x,\n        y: e.pageY - this.currentStartingPoint.y\n      })), filter(e => Math.abs(e.x) > this.draggingThreshold || Math.abs(e.y) > this.draggingThreshold), finalize(() => this.teardownDraggingSequence()));\n    }\n    registerDraggingHandler(isTouch) {\n      if (isTouch) {\n        this.handleRegistry.add({\n          teardown: this.renderer.listen('document', 'touchmove', e => {\n            if (this.currentDraggingSequence) {\n              this.currentDraggingSequence.next(e.touches[0] || e.changedTouches[0]);\n            }\n          })\n        });\n        this.handleRegistry.add({\n          teardown: this.renderer.listen('document', 'touchend', () => {\n            if (this.currentDraggingSequence) {\n              this.currentDraggingSequence.complete();\n            }\n          })\n        });\n      } else {\n        this.handleRegistry.add({\n          teardown: this.renderer.listen('document', 'mousemove', e => {\n            if (this.currentDraggingSequence) {\n              this.currentDraggingSequence.next(e);\n            }\n          })\n        });\n        this.handleRegistry.add({\n          teardown: this.renderer.listen('document', 'mouseup', () => {\n            if (this.currentDraggingSequence) {\n              this.currentDraggingSequence.complete();\n            }\n          })\n        });\n      }\n    }\n    teardownDraggingSequence() {\n      this.currentDraggingSequence = null;\n    }\n  }\n  NzDragService.ɵfac = function NzDragService_Factory(t) {\n    return new (t || NzDragService)(i0.ɵɵinject(i0.RendererFactory2));\n  };\n  NzDragService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzDragService,\n    factory: NzDragService.ɵfac,\n    providedIn: 'root'\n  });\n  return NzDragService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nfunction easeInOutCubic(t, b, c, d) {\n  const cc = c - b;\n  let tt = t / (d / 2);\n  if (tt < 1) {\n    return cc / 2 * tt * tt * tt + b;\n  } else {\n    return cc / 2 * ((tt -= 2) * tt * tt + 2) + b;\n  }\n}\nlet NzScrollService = /*#__PURE__*/(() => {\n  class NzScrollService {\n    constructor(ngZone, doc) {\n      this.ngZone = ngZone;\n      this.doc = doc;\n    }\n    /** Set the position of the scroll bar of `el`. */\n    setScrollTop(el, topValue = 0) {\n      if (el === window) {\n        this.doc.body.scrollTop = topValue;\n        this.doc.documentElement.scrollTop = topValue;\n      } else {\n        el.scrollTop = topValue;\n      }\n    }\n    /** Get position of `el` against window. */\n    getOffset(el) {\n      const ret = {\n        top: 0,\n        left: 0\n      };\n      if (!el || !el.getClientRects().length) {\n        return ret;\n      }\n      const rect = el.getBoundingClientRect();\n      if (rect.width || rect.height) {\n        const doc = el.ownerDocument.documentElement;\n        ret.top = rect.top - doc.clientTop;\n        ret.left = rect.left - doc.clientLeft;\n      } else {\n        ret.top = rect.top;\n        ret.left = rect.left;\n      }\n      return ret;\n    }\n    /** Get the position of the scoll bar of `el`. */\n    // TODO: remove '| Window' as the fallback already happens here\n    getScroll(target, top = true) {\n      if (typeof window === 'undefined') {\n        return 0;\n      }\n      const method = top ? 'scrollTop' : 'scrollLeft';\n      let result = 0;\n      if (this.isWindow(target)) {\n        result = target[top ? 'pageYOffset' : 'pageXOffset'];\n      } else if (target instanceof Document) {\n        result = target.documentElement[method];\n      } else if (target) {\n        result = target[method];\n      }\n      if (target && !this.isWindow(target) && typeof result !== 'number') {\n        result = (target.ownerDocument || target).documentElement[method];\n      }\n      return result;\n    }\n    isWindow(obj) {\n      return obj !== null && obj !== undefined && obj === obj.window;\n    }\n    /**\n     * Scroll `el` to some position with animation.\n     *\n     * @param containerEl container, `window` by default\n     * @param y Scroll to `top`, 0 by default\n     */\n    scrollTo(containerEl, y = 0, options = {}) {\n      const target = containerEl ? containerEl : window;\n      const scrollTop = this.getScroll(target);\n      const startTime = Date.now();\n      const {\n        easing,\n        callback,\n        duration = 450\n      } = options;\n      const frameFunc = () => {\n        const timestamp = Date.now();\n        const time = timestamp - startTime;\n        const nextScrollTop = (easing || easeInOutCubic)(time > duration ? duration : time, scrollTop, y, duration);\n        if (this.isWindow(target)) {\n          target.scrollTo(window.pageXOffset, nextScrollTop);\n        } else if (target instanceof HTMLDocument || target.constructor.name === 'HTMLDocument') {\n          target.documentElement.scrollTop = nextScrollTop;\n        } else {\n          target.scrollTop = nextScrollTop;\n        }\n        if (time < duration) {\n          reqAnimFrame(frameFunc);\n        } else if (typeof callback === 'function') {\n          // Caretaker note: the `frameFunc` is called within the `<root>` zone, but we have to re-enter\n          // the Angular zone when calling custom callback to be backwards-compatible.\n          this.ngZone.run(callback);\n        }\n      };\n      // Caretaker note: the `requestAnimationFrame` triggers change detection, but updating a `scrollTop` property or\n      // calling `window.scrollTo` doesn't require Angular to run `ApplicationRef.tick()`.\n      this.ngZone.runOutsideAngular(() => reqAnimFrame(frameFunc));\n    }\n  }\n  NzScrollService.ɵfac = function NzScrollService_Factory(t) {\n    return new (t || NzScrollService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT));\n  };\n  NzScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzScrollService,\n    factory: NzScrollService.ɵfac,\n    providedIn: 'root'\n  });\n  return NzScrollService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar NzBreakpointEnum = /*#__PURE__*/(() => {\n  (function (NzBreakpointEnum) {\n    NzBreakpointEnum[\"xxl\"] = \"xxl\";\n    NzBreakpointEnum[\"xl\"] = \"xl\";\n    NzBreakpointEnum[\"lg\"] = \"lg\";\n    NzBreakpointEnum[\"md\"] = \"md\";\n    NzBreakpointEnum[\"sm\"] = \"sm\";\n    NzBreakpointEnum[\"xs\"] = \"xs\";\n  })(NzBreakpointEnum || (NzBreakpointEnum = {}));\n  return NzBreakpointEnum;\n})();\nconst gridResponsiveMap = {\n  xs: '(max-width: 575px)',\n  sm: '(min-width: 576px)',\n  md: '(min-width: 768px)',\n  lg: '(min-width: 992px)',\n  xl: '(min-width: 1200px)',\n  xxl: '(min-width: 1600px)'\n};\nconst siderResponsiveMap = {\n  xs: '(max-width: 479.98px)',\n  sm: '(max-width: 575.98px)',\n  md: '(max-width: 767.98px)',\n  lg: '(max-width: 991.98px)',\n  xl: '(max-width: 1199.98px)',\n  xxl: '(max-width: 1599.98px)'\n};\nlet NzBreakpointService = /*#__PURE__*/(() => {\n  class NzBreakpointService {\n    constructor(resizeService, mediaMatcher) {\n      this.resizeService = resizeService;\n      this.mediaMatcher = mediaMatcher;\n      this.destroy$ = new Subject();\n      this.resizeService.subscribe().pipe(takeUntil(this.destroy$)).subscribe(() => {});\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n    }\n    subscribe(breakpointMap, fullMap) {\n      if (fullMap) {\n        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n        const get = () => this.matchMedia(breakpointMap, true);\n        return this.resizeService.subscribe().pipe(map(get), startWith(get()), distinctUntilChanged((x, y) => x[0] === y[0]), map(x => x[1]));\n      } else {\n        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n        const get = () => this.matchMedia(breakpointMap);\n        return this.resizeService.subscribe().pipe(map(get), startWith(get()), distinctUntilChanged());\n      }\n    }\n    matchMedia(breakpointMap, fullMap) {\n      let bp = NzBreakpointEnum.md;\n      const breakpointBooleanMap = {};\n      Object.keys(breakpointMap).map(breakpoint => {\n        const castBP = breakpoint;\n        const matched = this.mediaMatcher.matchMedia(gridResponsiveMap[castBP]).matches;\n        breakpointBooleanMap[breakpoint] = matched;\n        if (matched) {\n          bp = castBP;\n        }\n      });\n      if (fullMap) {\n        return [bp, breakpointBooleanMap];\n      } else {\n        return bp;\n      }\n    }\n  }\n  NzBreakpointService.ɵfac = function NzBreakpointService_Factory(t) {\n    return new (t || NzBreakpointService)(i0.ɵɵinject(NzResizeService), i0.ɵɵinject(i2.MediaMatcher));\n  };\n  NzBreakpointService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzBreakpointService,\n    factory: NzBreakpointService.ɵfac,\n    providedIn: 'root'\n  });\n  return NzBreakpointService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nlet NzDestroyService = /*#__PURE__*/(() => {\n  class NzDestroyService extends Subject {\n    ngOnDestroy() {\n      this.next();\n      this.complete();\n    }\n  }\n  NzDestroyService.ɵfac = /* @__PURE__ */function () {\n    let ɵNzDestroyService_BaseFactory;\n    return function NzDestroyService_Factory(t) {\n      return (ɵNzDestroyService_BaseFactory || (ɵNzDestroyService_BaseFactory = i0.ɵɵgetInheritedFactory(NzDestroyService)))(t || NzDestroyService);\n    };\n  }();\n  NzDestroyService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzDestroyService,\n    factory: NzDestroyService.ɵfac\n  });\n  return NzDestroyService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ImagePreloadService = /*#__PURE__*/(() => {\n  class ImagePreloadService {\n    constructor(document, platform) {\n      this.document = document;\n      this.platform = platform;\n      this.counter = new Map();\n      this.linkRefs = new Map();\n    }\n    addPreload(option) {\n      if (this.platform.isBrowser) {\n        return () => void 0;\n      }\n      const uniqueKey = `${option.src}${option.srcset}`;\n      let currentCount = this.counter.get(uniqueKey) || 0;\n      currentCount++;\n      this.counter.set(uniqueKey, currentCount);\n      if (!this.linkRefs.has(uniqueKey)) {\n        const linkNode = this.appendPreloadLink(option);\n        this.linkRefs.set(uniqueKey, linkNode);\n      }\n      return () => {\n        if (this.counter.has(uniqueKey)) {\n          let count = this.counter.get(uniqueKey);\n          count--;\n          if (count === 0) {\n            const linkNode = this.linkRefs.get(uniqueKey);\n            this.removePreloadLink(linkNode);\n            this.counter.delete(uniqueKey);\n            this.linkRefs.delete(uniqueKey);\n          } else {\n            this.counter.set(uniqueKey, count);\n          }\n        }\n      };\n    }\n    appendPreloadLink(option) {\n      const linkNode = this.document.createElement('link');\n      linkNode.setAttribute('rel', 'preload');\n      linkNode.setAttribute('as', 'image');\n      linkNode.setAttribute('href', option.src);\n      if (option.srcset) {\n        linkNode.setAttribute('imagesrcset', option.srcset);\n      }\n      this.document.head.appendChild(linkNode);\n      return linkNode;\n    }\n    removePreloadLink(linkNode) {\n      if (this.document.head.contains(linkNode)) {\n        this.document.head.removeChild(linkNode);\n      }\n    }\n  }\n  ImagePreloadService.ɵfac = function ImagePreloadService_Factory(t) {\n    return new (t || ImagePreloadService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1.Platform));\n  };\n  ImagePreloadService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ImagePreloadService,\n    factory: ImagePreloadService.ɵfac,\n    providedIn: 'root'\n  });\n  return ImagePreloadService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ImagePreloadService, NzBreakpointEnum, NzBreakpointService, NzDestroyService, NzDragService, NzResizeService, NzScrollService, NzSingletonService, gridResponsiveMap, siderResponsiveMap };\n//# sourceMappingURL=ng-zorro-antd-core-services.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}